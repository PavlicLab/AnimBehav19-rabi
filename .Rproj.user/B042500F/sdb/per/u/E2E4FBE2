{
    "collab_server" : "",
    "contents" : "tweaker <- function(combos, redundancy, num.tries = 10, available.colors = NULL) {\n  {\n    if (missing(redundancy)) {\n      stop(\"Error: you need specify to how many erasure events the IDs should be robust. Note, an increase in robustness requires an increase in the total length of the ID. \")\n    }\n    # if (redundancy >= total_length || redundancy == 0) {\n    #   stop(\"Error: the code must be robust to at least one erasure. It also cannot be robust to a number of positions equal to or greater than the total length.\")\n    # }\n    if (class(num.tries) != \"numeric\") {\n      stop(paste0(\"Error: the variable 'num.tries' must be of the class 'numeric,' not '\", class(num.tries),\".'\"))\n    }\n  }\n  #you DON'T generate all sequences, you're given them\n  \n  \n  tester <- function(combos, redundancy) {\n    \n    combo.list <- split(combos, 1:nrow(combos))\n    #pick a random sequence and start making the \"safe\" list with it\n    x <- sample(1:length(combo.list), 1)\n    new.combs <- combo.list[x]\n    names(new.combs) <- NULL\n    #remove everything too similar to the chosen sequence from the old list\n    combo.list <- combo.list[seq_distmatrix(combo.list, new.combs, method = \"hamming\")[, length(new.combs)] > redundancy]\n    names(combo.list) <- 1:length(combo.list)\n    #do this again and again until everything is removed\n    while (length(combo.list) > 0) {\n      x <- sample(1:length(combo.list), 1)\n      new.combs[length(new.combs) + 1] <- (combo.list[x])\n      combo.list <- combo.list[seq_distmatrix(combo.list, new.combs, method = \"hamming\")[, length(new.combs)] > redundancy]\n      if (length(combo.list) != 0) {\n        names(combo.list) <- 1:length(combo.list)\n      }\n    }\n    # print(length(new.combs)) table(unlist(seq_distmatrix(new.combs,new.combs,method='hamming')))\n    return(new.combs)\n  }\n  #run through the function several times and keep the best\n  temp1 <- NULL\n  temp2 <- 0\n  for (i in 1:num.tries) {\n    temp1 <- invisible(tester(combos, redundancy))\n    if (length(temp1) > length(temp2))\n      temp2 <- temp1\n  }\n  temp2 <- codes_to_colors(temp2, available.colors)\n  return(temp2)\n}\n\n\n#generate all sequences and turn into a list\ncombos <- gtools::permutations(7, 5, repeats.allowed = TRUE) - 1\n\n\ncombos <-\n  combos[which(\n    ((\n      (odd(combos[,1]) & odd(combos[,3]) & even(combos[,2]) & even(combos[,4])) |\n      (even(combos[,1]) & even(combos[,3]) & odd(combos[,2]) & odd(combos[,4]))\n    ) ) \n  ), ]\n\ntweaker(combos[,1:5],2, num.tries = 5)->a\na <- t(do.call(\"cbind\",a))\na<-cbind(a,apply(a,1, function(x) ifelse(odd(x[1]),1,0)))\n\na<-codes\nfor (i in 0:6) { \n  for (j in 0:6){\n    print((a[which((a[,3]==j | a[,4]==j)&(a[,2]==i | a[,1]==i)), ]))\n  }\n}\n\n\n#=======================================\n#===================================\n\n#generate all sequences and turn into a list\ncombos <- gtools::permutations(8, 5, repeats.allowed = TRUE) - 1\n\ncombos <- \n  combos[which(\n    (combos[,1] == combos[,3]) & (combos[,2] != combos[,4])\n  ), ]\n\n\ntweaker(combos,2, num.tries = 10)->a\na <- t(do.call(\"cbind\",a))\n\nfor (i in 0:6) { \n  for (j in 0:6){\n    print(dim(a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ])[1])\n  }\n}\n#==============\n\n\n\n\n\ntweaker(combos,2, num.tries = 1)->a\na <- t(do.call(\"cbind\",a))\n\nfor (i in 0:6) { \n  for (j in 0:6){\n    print(dim(a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ])[1])\n  }\n}\n\n\n\ncodes <- split(codes, 1:nrow(codes))\nnames(codes) <- NULL\n\n\n",
    "created" : 1507659331278.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "0|82|47|0|\n",
    "hash" : "4013218144",
    "id" : "E2E4FBE2",
    "lastKnownWriteTime" : 30399761348100200,
    "last_content_update" : 1507845038385,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}