{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Tweaking a Coding Scheme: Bird Tagging\"\nauthor: \"Andrew Burchill\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Tweaking a Coding Scheme: Bird Tagging}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\nIn this vignette, we will tweak a color coding scheme generated by the `reed_solomon()` function. In our particular hypothetical situation, we plan on putting color bands around the legs of some bird. We have eight different band colors, and we want to put five bands on each bird: two bands below each of the bird's \"ankles\" (around the tarsometatarsus) and one band above the bird's right \"ankle\" joint (around the right tibiotarsus). A horrible \"graphical\" representation can be seen below, where `{1}`, `{2}`, `{3}`, `{4}`, and `{5}` refer to the five unique banding positions.\n\n```{r, echo=FALSE, collapse=TRUE,comment=\"\"}\ncat(\"     |   |            |  {5}\\n     o   o            o   o\\n     |   |     =>    {1} {3}\\n     .   .           {2} {4}\\n    /|\\\\ /|\\\\          /|\\\\ /|\\\\\")\n\n```\n\nLet us say that these bands fall off somewhat frequently; we want our coding scheme to be robust to the loss of two bands. If these bands occupy unique positions and can't be moved around, we can use the `reed_solomon()` function without further modification.\n```{r, results='hide'}\nalphabet <- 8      # the number of colors we have\ntotal_length <- 5  # the number of positions we want band\nredundancy <- 2    # how many bands we can lose but still ID perfectly\ncodes <- rabi::reed_solomon(total_length, redundancy, alphabet)\nhead(codes, n = 10L)\n```\n```{r, echo=FALSE}\ncodes <- t(do.call(\"cbind\",codes))\nknitr::kable(head(codes, n = 10L), col.names = c(\"{1}\",\"{2}\",\"{3}\",\"{4}\",\"{5}\"), align = \"c\", caption = \"ID sequences in the unaltered list\")\n```\n\nCongratualtions! It's as simple as one line of code. **Note that our scheme contains `r dim(codes)[1]` unique IDs.**\n\n##Actually... it's not so simple\n\nSadly, things get a bit trickier. In reality, these bands may be realtively loose around the legs of the bird. The unique positions of bands `{1}` and `{3}` are probably only maintained due to the physical presence of bands `{2}` and `{4}`. If `{2}` or `{4}` were to somehow be removed, the band above them would succumb to gravity and descend into the newly vacated position. In the below \"diagram,\" we see that a loss of both `{1}` and `{2}` will yield the same final configuration. In this case, it would be impossible to tell the original position of the remaining band. \n```{r, echo=FALSE, collapse=TRUE,comment=\"\"}\ncat(\"     |  {5}           |  {5}           |  {5}\\n     o   o            o   o            o   o\\n    {1} {3}   AND     x  {3}    =>     |  {3}\\n     x  {4}          {2} {4}          {?} {4}\\n    /|\\\\ /|\\\\          /|\\\\ /|\\\\          /|\\\\ /|\\\\\")\ntweaker <- function(combos, redundancy, num.tries = 10, available.colors = NULL) {\n  {\n    if (missing(redundancy)) {\n      stop(\"Error: you need specify to how many erasure events the IDs should be robust. Note, an increase in robustness requires an increase in the total length of the ID. \")\n    }\n    # if (redundancy >= total_length || redundancy == 0) {\n    #   stop(\"Error: the code must be robust to at least one erasure. It also cannot be robust to a number of positions equal to or greater than the total length.\")\n    # }\n    if (class(num.tries) != \"numeric\") {\n      stop(paste0(\"Error: the variable 'num.tries' must be of the class 'numeric,' not '\", class(num.tries),\".'\"))\n    }\n  }\n  #you DON'T generate all sequences, you're given them\n  \n  \n  tester <- function(combos, redundancy) {\n    \n    combo.list <- split(combos, 1:nrow(combos))\n    #pick a random sequence and start making the \"safe\" list with it\n    x <- sample(1:length(combo.list), 1)\n    new.combs <- combo.list[x]\n    names(new.combs) <- NULL\n    #remove everything too similar to the chosen sequence from the old list\n    combo.list <- combo.list[stringdist::seq_distmatrix(combo.list, new.combs, method = \"hamming\")[, length(new.combs)] > redundancy]\n    names(combo.list) <- 1:length(combo.list)\n    #do this again and again until everything is removed\n    while (length(combo.list) > 0) {\n      x <- sample(1:length(combo.list), 1)\n      new.combs[length(new.combs) + 1] <- (combo.list[x])\n      combo.list <- combo.list[stringdist::seq_distmatrix(combo.list, new.combs, method = \"hamming\")[, length(new.combs)] > redundancy]\n      if (length(combo.list) != 0) {\n        names(combo.list) <- 1:length(combo.list)\n      }\n    }\n    # print(length(new.combs)) table(unlist(seq_distmatrix(new.combs,new.combs,method='hamming')))\n    return(new.combs)\n  }\n  #run through the function several times and keep the best\n  temp1 <- NULL\n  temp2 <- 0\n  for (i in 1:num.tries) {\n    temp1 <- invisible(tester(combos, redundancy))\n    if (length(temp1) > length(temp2))\n      temp2 <- temp1\n  }\n  temp2 <- rabi::codes_to_colors(temp2, available.colors)\n  return(temp2)\n}\n\n\n```\nIt becomes clear that a loss in `{1}` would make the ID code **3,4**,2,4,0 indistinguishable from **4,3**,2,4,0 or **5,3**,2,4,0 or **3,0**,2,4,0 etc. (A similar dilemna is caused by losses in `{3}` or `{4}`.)\n\nThe best fix for this is not easily apparent. Let's try to work around it just by manipulating our coding scheme.\n\n##Pruning the coding list\n\nOne possible idea: prune the list of codes so that the top bands, `{1}` and  `{3}`, are only odd numbers and the bottom bands, `{2}` and  `{4}`, are only even numbers. That way, a lone even-numbered band indicates that the upper band has been lost, etc.\n\n```{r, results='hide',echo=FALSE}\ncodes <- rabi::reed_solomon(total_length = 5, redundancy = 2, alphabet = 8)\ncodes <- t(do.call(\"cbind\",codes))  \n```\n```{r}\n #create a function for determining odd or even\nodd <- function(x){ x %% 2 == 1 }\n # only select the codes where {1} and {3} are odd, and {2} and {4} are even\ncodes <- \n  codes[which(odd(codes[,1]) & odd(codes[,3]) & !odd(codes[,2]) & !odd(codes[,4])), ]\nprint(paste0(\"Our new list contains \", dim(codes)[1], \" unique IDs.\"))\n```\n\n###Using the `tweaker()` function\nDamn. That's almost nothing... However, we can possibly increase that number by using the `tweaker()` function. It's the same as `brute_IDs()`, but instead of pruning down a list of ALL possible ID sequences, we can specify our constraints first and prune down that list.\n\n```{r}\n #create a matrix of all possible sequences\nperms <- rep(list(seq_len(alphabet)),total_length)\ncombos <- as.matrix(expand.grid(perms)) - 1\n #only keep sequences that fit our constraints\ncombos <- \n  combos[which(odd(combos[,1]) & odd(combos[,3]) & !odd(combos[,2]) & !odd(combos[,4])), ]\ncodes <- tweaker(combos, redundancy, num.tries = 1)  #we're only running it once for speed\nprint(paste0(\"The 'tweaked' list contains \", length(codes), \" unique IDs.\"))\n\n```\n\n```{r}\n #create a matrix of all possible sequences\nperms <- rep(list(seq_len(alphabet)),total_length)\ncombos <- as.matrix(expand.grid(perms)) - 1\n #only keep sequences that fit our constraints\ncombos <- \n  combos[which(odd(combos[,1]) & !odd(combos[,2])), ]\ncodes <- tweaker(combos, redundancy, num.tries = 1)  #we're only running it once for speed\nprint(paste0(\"The 'tweaked' list contains \", length(codes), \" unique IDs.\"))\n\n```\n\nOkay, that's still not much better... To really make this work, we'll probably need to change the physical setup of the tagging system.\n\n##Physical changes\n\nA very simple solution: on the upper color bands `{1}` and `{3}`, use a sharpie to add dark vertical stripes. Adding additional markings can give the banding positions uniqueness in the face of gravity and detachment. However, one could imagine many reasons why such a last-minute fix would not be ideal.\n\n```{r}\n #create a matrix of all possible sequences\nperms <- rep(list(seq_len(alphabet)),total_length)\ncombos <- as.matrix(expand.grid(perms)) - 1\n\ncombos <- combos[which((\n      (odd(combos[,1]) & odd(combos[,3]) & !odd(combos[,2]) & !odd(combos[,4])) |\n      (!odd(combos[,1]) & !odd(combos[,3]) & odd(combos[,2]) & odd(combos[,4]))\n      )), ]\ncodes <- tweaker(combos, redundancy, num.tries = 1)  #we're only running it once for speed\nprint(paste0(\"The 'tweaked' list contains \", length(codes), \" unique IDs.\"))\n\n```\n\n\nAlso a quote using `>`:\n\n> \"He who gives up [code] safety for [code] speed deserves neither.\"\n([via](https://twitter.com/hadleywickham/status/504368538874703872))\n",
    "created" : 1507593662815.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "38|82|85|0|\n",
    "hash" : "410654417",
    "id" : "148D57A2",
    "lastKnownWriteTime" : 1507845750,
    "last_content_update" : 1507845750270,
    "path" : "~/R sandbox/color_code_package/rabi/vignettes/loosebirdtag.Rmd",
    "project_path" : "vignettes/loosebirdtag.Rmd",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}