sapply(a, function(x) ifelse(odd(x[1]),x*20,x))
codes
sapply(a, function(x) ifelse(odd(x[1]),append(x,1),append(x,0)))
apply(a, function(x) ifelse(odd(x[1]),append(x,1),append(x,0)))
lapply(a, function(x) ifelse(odd(x[1]),append(x,1),append(x,0)))
lapply(a, function(x) ifelse(odd(x[1]),x,x))
a
lapply(a, function(x) ifelse(odd(x[1]),x,x))
a
lapply(a, function(x) ifelse(odd(x[1]),print(x),x))
lapply(a, function(x) ifelse(odd(x[1]),class(x),x))
sapply(a, function(x) ifelse(odd(x[1]),class(x),x))
sapply(a, function(x) ifelse(odd(x[1]),class(x),x),simplify = "array")
lapply(a, function(x) ifelse(odd(x[1]),class(x),x),simplify = "array")
lapply(a, function(x) ifelse(odd(x[1]),class(x),x))
lapply(a, function(x) ifelse(odd(x[1]),class(x),as.list(x)))
lapply(a, function(x) print(x))
lapply(a, function(x) print(x[2]))
lapply(a, function(x) print(x[[2]]))
lapply(a, function(x) print(x))
lapply(a, function(x) print(x))[1]
lapply(a, function(x) print(x))[[1]]
lapply(a, function(x) print(x))[1]
lapply(a, function(x) print(x))[1][1]
lapply(a, function(x) print(x))[[1][1]]
lapply(a, function(x) print(x))[[1]]
lapply(a, function(x) print(x))[[1]]->b
b
lapply(a, function(x) print(x))[[1]][1]->b
b
lapply(a, function(x) print(x[[1]][1]))
lapply(a, function(x) print(x[[1]][2]))
lapply(a, function(x) print(x))[[1]][1]->b
b
lapply(a, function(x) print(x))[[1]][2]->b
b
lapply(a, function(x) print(x[[1]][1]))
lapply(a, function(x) print(x[[2]][1]))
lapply(a, function(x) print(x[2][1]))
lapply(a, function(x) print(x[2]))
lapply(a, function(x) print(x[1],x[2]))
lapply(a, function(x) print(paste0(x[1],x[2])))
sapply(a, function(x) print(paste0(x[1],x[2])))
sapply(a, function(x) print(paste0(append(x,1))))
sapply(a, function(x) (append(x,1)))
lapply(a, function(x) (append(x,1)))
lapply(a, function(x) ifelse(odd(x[1]),(append(x,1)),(append(x,0)))
lapply(a, function(x) ifelse(odd(x[1]),(append(x,1)),(append(x,0))))
lapply(a, function(x) ifelse(odd(x[1]),append(x,1),append(x,0)))
lapply(a, function(x) ifelse(TRUE),append(x,1),append(x,0)))
lapply(a, function(x) ifelse(TRUE,append(x,1),append(x,0)))
lapply(a, function(x) ifelse(TRUE,append(x,1),append(x,0)))
lapply(a, function(x) (append(x,1)))
lapply(a, function(x) if(TRUE) append(x,1))
odd(1)
lapply(a, function(x) if(odd(x[[1]])) append(x,1))
lapply(a, function(x) if(odd(x[[1]])) {append(x,1)} else {append(x,0)})
codes
#add either a 1 (indicating left) or a
codes <- lapply(codes, function(x) if(odd(x[[1]])) {append(x,"L")} else {append(x,"R")})
codes
codes <- t(do.call("cbind",codes))
knitr::kable(head(codes, n = 10L), col.names = c("{1}","{2}","{3}","{4}","{5}","Left or Right"), align = "c", caption = "ID sequences in variable position list")
cat("     |  {5}          {5}  |\n     o   o            o   o\n    {1} {3}    OR    {1} {3}\n    {2} {4}          {2} {4}\n    /|\\ /|\\          /|\\ /|\\")
```{r, results='hide'}
alphabet <- 8      # the number of colors we have
total.length <- 5  # the number of positions we want band
redundancy <- 2    # how many bands we can lose but still ID perfectly
codes <- rabi::reed_solomon(total.length, redundancy, alphabet)
codes
a<-codes
a <- t(do.call("cbind",a))
for (i in 0:6) {
for (j in 0:6){
print(dim(a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ])[1])
}
}
for (i in 0:6) {
for (j in 0:6){
print((a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ])[1])
}
}
for (i in 0:6) {
for (j in 0:6){
print((a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ]))
}
}
for (j in 0:6){
print((a[which((a[,1] == i | a[,2] == i) & (a[,3]==j | a[,4]==j)), ]))
}
i
j
(a[which(( (a[,3]==j | a[,4]==j)), ])
(a[which(( (a[,3]==j | a[,4]==j)), ]))
(a[which( (a[,3]==j | a[,4]==j)), ]
)
(a[which( (a[,3]==j | a[,4]==j) & a[,5==4]), ])
(a[which( (a[,3]==j | a[,4]==j) & a[,5]==4), ])
j=5
(a[which( (a[,3]==j | a[,4]==j) & a[,5]==4), ])
seq_distmatrix((a[which( (a[,3]==j | a[,4]==j) & a[,5]==4), ]),(a[which( (a[,3]==j | a[,4]==j) & a[,5]==4), ]),method="hamming")
(a[which( (a[,3]==j | a[,4]==j) & a[,5]==4), ])->b
b->codes
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
codes->a
seq_distmatrix(a,a,method="hamming")
robo <- function(codes) {
if (class(codes) == "matrix") {
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
} else if (class(codes) != "list") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence. See the examples for a better idea.")
}
table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
}
a
robo(codes)
list.files
list.files()
a
combos2 <-
combos[which(
(odd(combos[,3]) & !odd(combos[,4]) & (odd(combos[,5]) | odd(combos[,1]+combos[,2]))) |
(!odd(combos[,3]) & odd(combos[,4]) & (!odd(combos[,5]) | !odd(combos[,1]+combos[,2])))
), ]
codes <- rabi::tweaker(combos2, redundancy, num.tries = 2)
codes
robo(codes)
robo(codes)[1]
robo(codes)->b
b
b$'0'
b['0']
b[0]
b['0']<-NULL
class(b)
as.list(b)
as.list(b)->b
b$'0'
b$'0'<-NUL
b$'0'<-NULL
b
table(b)
as.table(b)
b
codes
unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming"))
table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
b
print(b)
hams <- as.list(hams)
hms
hams
codes
hams$'0' <- hams$'0' - length(codes)
hams
names(hams)
paste0(names(hams),"hey")
paste0("dist.",names(hams))
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
names(hams) <- paste0("dist.",names(hams))
hams
hams["dist.0"]
length(codes)
codes[[1]]
hams
unlist(hams)
unlist(hams)->b
b
class(b)
class(hams)
b[1]
b[2]
relist(b)
unlist(options())
unlist(options(), use.names = FALSE)
hamms
hams
unlist(hams)
total.length <- 4
redundancy <- 2
alphabet <- 5
reed_solomon(total.length, redundancy, alphabet)
library(rabi)
reed_solomon(total.length, redundancy, alphabet)
how_robust <- function(codes) {
if (class(codes) == "matrix") {
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
} else if (class(codes) != "list") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
} else if (class(codes[[1]] != "numeric")) {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
}
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
names(hams) <- paste0("dist.",names(hams))
return(unlist(hams))
}
reed_solomon(total.length, redundancy, alphabet)->codes
how_robust(codes)
how_robust <- function(codes) {
if (class(codes) == "matrix") {
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
} else if (class(codes) != "list") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
} else if (class(codes[[1]]) != "numeric") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
}
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
names(hams) <- paste0("dist.",names(hams))
return(unlist(hams))
}
how_robust(codes)
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
hamms
hamms
hams
hams$'9'
if (hams$'9' == 0) print("hey")
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
try(if (hams$'0' == 0) hams$'0' <- NULL, silent = TRUE)
hams
how_robust <- function(codes) {
if (class(codes) == "matrix") {
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
} else if (class(codes) != "list") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
} else if (class(codes[[1]]) != "numeric") {
stop("Error: the variable 'codes' must be either a list of numeric sequences or a matrix, where each row is a unique sequence.")
}
hams <- table(unlist(stringdist::seq_distmatrix(codes,codes,method = "hamming")))
hams <- as.list(hams)
try(hams$'0' <- hams$'0' - length(codes), silent = TRUE)
try(if (hams$'0' == 0) hams$'0' <- NULL, silent = TRUE)
names(hams) <- paste0("dist.",names(hams))
return(unlist(hams))
}
how_robust(codes)
document()
library(devtools)
document()
devtools::build_vignettes()
devtools::build_vignettes()
library(rabi)
?how_robust
sessionInfo()
sessionInfo()[1]
lapply(pkg, detach, character.only = TRUE, unload = TRUE)
sessionInfo()[3]
sessionInfo()[6]
sessionInfo()
pkg<-c("package:devtools")
lapply(pkg, detach, character.only = TRUE, unload = TRUE)
pkg<-c("package:devtools_1.13.3")
lapply(pkg, detach, character.only = TRUE, unload = TRUE)
detach(devtools)
detach("devtools")
detach("package:devtools")
detach("package:devtools", character.only = TRUE)
detach("package:devtools_1.13.3", character.only = TRUE)
detach("package:devtools_1.13.3")
detach(package:devtools_1.13.3)
detach(package:devtools)
library("devtools", lib.loc="~/R/win-library/3.2")
detach(package:devtools)
sessionInfo()
library("stringdist", lib.loc="~/R/win-library/3.2")
detach("package:stringdist", unload=TRUE)
library("utils", lib.loc="C:/Program Files/R/R-3.2.5/library")
detach("package:utils", unload=TRUE)
sessionInfo()
reed_solomon(4,1,5)
brute_IDs(total.length, redundancy, alphabet, num.tries = 1)
color.names <- c("blue","red","green","pink","yellow-with-a-stripe")
color.names <- c("blue","red","green","pink","yellow-with-a-stripe")
c("blue","red","green","pink","yellow-with-a-stripe")
test <- c("blue","red","green","pink","yellow-with-a-stripe")
test
utils::object.size
?utils::object.size
color.names
codes_to_colors(codes, color.names)
alphabet
total.length <- 6
redundancy <- 2
alphabet <- 5
codes <- reed_solomon(total.length, redundancy, alphabet)
codes_to_colors(codes, color.names)
how_many(total.length, redundancy, alphabet)
library("utils", lib.loc="C:/Program Files/R/R-3.2.5/library")
library(devtools)
document()
library(rabi)
?rabi
knitr::opts_chunk$set(comment = "#>")
print(paste0("Our list contains ", length(codes), " unique IDs."))
odd <- function(x){ x %% 2 == 1 }
#turn the code list into a matrix for easier manipulation
codes <- t(do.call("cbind",codes))
#only select the codes where {1} and {3} are odd, and {2} and {4} are even
codes <-
codes[which(odd(codes[,1]) & odd(codes[,3]) & !odd(codes[,2]) & !odd(codes[,4])), ]
print(paste0("Our new list contains ", dim(codes)[1], " unique IDs."))
alphabet <- 8      # the number of colors we have
total.length <- 5  # the number of positions we want band
redundancy <- 2    # how many bands we can lose but still ID perfectly
codes <- rabi::reed_solomon(total.length, redundancy, alphabet)
build()
document()
devtools::build_vignettes()
library(rabi)
document()
library(rabi)
?tweaker
document()
library(rabi)
simple_code(4,4)
simple_code <- function(total.length, alphabet, available.colors = NULL){
if (missing(alphabet)) {
stop("Error: you need to enter an 'alphabet size,' e.g. the number of paint colors you have")
}
if (missing(total.length)) {
stop("Error: you need to enter the total length of the ID, e.g. how many color bands or paint drops on each organism")
}
perms <- rep(list(seq_len(alphabet)),total.length - 1 )
df <- as.matrix(expand.grid(perms)) - 1
df <- cbind(df,apply(df, 1, function(x) alphabet - (sum(x) %% alphabet)))
df[df == alphabet] <- 0
df <- split(df, 1:nrow(df))
names(df) <- NULL
df <- codes_to_colors(df, available.colors)
if (class(df[[1]]) == "numeric") message(paste0("Each ID sequence sums to a multiple of ", alphabet, "."))
return(df)
}
simple_code(4,4)
document()
library(rabi)
document()
library(rabi)
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
document()
library(rabi)
document()
library(rabi)
document()
library(rabi)
document()
library(rabi)
document()
library(rabi)
session_info()
devtools::use_readme_rmd()
document()
library(rabi)
?rabi
total.length <- 4  #we have six positions to mark,
redundancy <- 2    #we want robustness to single erasures,
alphabet <- 5      #and we currently have five types of paint in stock
codes <- reed_solomon(total.length, redundancy, alphabet)
codes
redundancy <- 1    #we want robustness to single erasures,
codes <- reed_solomon(total.length, redundancy, alphabet)
codes
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
rabi::codes_to_colors(codes, paint.names)
order(c(2,1,3))
sort(c(2,1,3))
library(rabi)
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
color.codes <- rabi::codes_to_colors(codes, paint.names)
color.codes
codes <- t(do.call("cbind",codes))
color.codes <- rabi::codes_to_colors(codes, paint.names)
order(c(2,1,3), decreasing =TRUE)
sort(c(2,1,3), decreasing =TRUE)
available.colors = paint.names
original.nums <- sort(unique(unlist(codes)))
original.nums
mapping <- setNames(available.colors, original.nums)
original.nums <- sort(unique(unlist(codes)))
original.nums
codes
(unique(unlist(codes)
)
)
unlist(codes)
unlist(unlist(codes))
codes
codes
unlist(codes)
unlist(codes, recursive = TRUE)
codes <- split(codes, 1:nrow(codes))
names(codes) <- NULL
original.nums <- sort(unique(unlist(codes)))
original.nums
mapping <- setNames(available.colors, original.nums)
mapping
mapping <- mapping[sort(unlist(mapping))]
mapping
mapping[order(unlist(mapping), decreasing = TRUE)]
mapping
mapping <- setNames(available.colors, original.nums)
mapping
library(rabi)
total.length <- 4  #we have four places to put paint,
redundancy <- 1    #we want robustness to single erasures,
alphabet <- 5      #and we currently have five types of paint in stock
#reed_solomon() is one of the functions that can generate codes
codes <- rabi::reed_solomon(total.length, redundancy, alphabet)
#prep the output to be displayed in a table
codes <- t(do.call("cbind",codes))
knitr::kable(
head(codes, n = 10L),
col.names = c("Head","Thorax","R. Abdomen","L. Abdomen"),
align = "c", caption = "ID sequences for ants")
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
color.codes <- rabi::codes_to_colors(codes, paint.names)
codes <- t(do.call("cbind",codes))
color.codes <- t(do.call("cbind",color.codes))
knitr::kable(
head(color.codes, n = 10L),
col.names = c("Head","Thorax","R. Abdomen","L. Abdomen"),
align = "c", caption = "ID sequences for ants")
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
color.codes <- rabi::codes_to_colors(codes, paint.names)
#prep the output to be displayed in a table
color.codes <- t(do.call("cbind",color.codes))
mapping
message(mapping)
message(print.table(mapping))
cat(print.table(mapping))
message(paste0(capture.output(mapping), collapse = "\n"))
library(rabi)
library(rabi)
paint.names <- c("red","light blue", "greenish", "off-white", "yellow")
color.codes <- rabi::codes_to_colors(codes, paint.names)
?vignette
?vignettes
vignette(package=rabi)
vignette(package='rabi')
vignette(loosebirdtag,package='rabi')
vignette('loosebirdtag',package='rabi')
use_news_md(pkg="stringdist")
use_cran_badge()
use_cran_badge(pkg = "rabi")
use_gpl3_license()
use_vignette()
use_vignette("loosebirdtag")
use_rstudio()
use_news_md()
document
document()
library(rabi)
use_news_md()
use_news_md()
devtools::use_build_ignore("NEWS.md")
library(rabi)
document()
library(rabi)
document()
?rabi
library(rabi)
?rabi
document()
library(rabi)
?ra
?rabi
document()
d
library(rabi)
show_news()
show_news()
library(rabi)
show_news()
library(rabi)
show_news()
show_news(pkg="devtools")
show_news(devtools)
library(rabi)
document()
library(rabi)
?tweaker
document()
document()
library(rabi)
rmarkdown::render("README.Rmd")
document()
library(rabi)
document()
document()
devtools::build_vignettes()
document()
document()
document()
rmarkdown::render("README.Rmd")
document()
document()
